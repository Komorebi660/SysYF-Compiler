整体实现思路如下：

首先定义符号表，使用`C++`的`map`类，它通过变量名索引，元素的值为类型结构体`Entry`，由于不同作用域的符号表不同，所以对不同作用域的符号表使用`C++`的`list`类按顺序串联起来，每次进入一个新的作用域(如函数定义、语句块)时，在`list`的头部插入新的符号表，当离开作用域时，则删去`list`的头部元素。在查找符号表时，从`list`的头部开始查起，往后遍历，直到找到元素，这样的查找方式正好符合作用域由小到大的查找方式。

在原来的代码基础上，对所有的节点展开，也即调用`accept()`函数，保证语义检查覆盖所有可能的语句。

- 取模的语义检查基本同助教提供的代码的思路；
- 对于变量检查，主要使用了符号表，在`VarDef`节点作插入符号表的操作，同时检查是否重定义；在`LVal`节点作查询符号表操作，同时检查是否出现变量未定义的情况；
- 函数声明与定义的检查方法与变量相同；
- 在比较形参与实参的一致性时，在`visitor`类的内部定义了一个私有变量`current_type`，用于保存当前分析的元素的变量类型，在`FuncCallStmt`节点，查询符号表找函数的定义，之后对`FuncCallStmt`的`params`中的每一个元素与查符号表得到的函数定义时的参数列表中的每一个元素逐一对比，完成一致性检查。

主要的实现亮点我认为是数据结构的选用，通过链表的方式组织不同作用域的符号表，而没有使用课本上的栈的方式，使得遍历(`lookup`)更为方便，除此以外，我还将插入符号表以及`lookup`的操作封装在`visitor`类当中，这样，在重写`visit()`函数时可以更加简洁。