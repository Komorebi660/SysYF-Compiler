## 实现思路

下面分析每一个节点的`visit()`函数：

#### InitVal

由于初始化可以出现在全局变量，也可以出现在局部变量，所以本节点仅仅将所有初始化的`value`存进`Inititem`这一结构体中，因为该节点本身是嵌套定义，所以这个结构体也为嵌套定义：

```c
typedef struct InitItem
{
    bool isValue;   //是否为表达式
    Value *expr;    //表达式的value
    std::vector<InitItem> list; //存放数组的初始化向量
} Inititem;
```

该节点访问完后，将得到的初始化结果存在全局变量`recentInitItem`中，返回给`VarDef`节点处理。

#### FuncDef

主要工作有：

- 进入`param_list`获取形参列表，然后构建`FunctionType`，插入`scope`中，同时存储在全局变量中；
- 设置新的`BasicBlock`，根据形参列表在其中分配参数空间并`store`参数的值；
- 分配返回值(区分返回为空的情况)以及返回语句块`BasicBlock`，将这些值保存到全局变量中，便于后续`return`语句返回；
- 进入作用域，处理`body`.

#### FuncFParamList

直接遍历每一个`params`即可

#### FuncParam

将参数类型以及名字分别`push`到全局变量`Param`和`Param_names`中，便于`FuncDef`处理。

#### VarDef

根据`array_length`域创建对应的`type`. 注意区分全局变量与局部变量，全局变量使用`GlobalVariable::create()`创建，局部变量使用`builder->create_alloca()`创建，然后将所得结果插入符号表。

根据是否初始化，判断是否进入`initializers`节点，全局变量的初始化蕴含`GlobalVariable::create()`的参数中，局部变量初始化则需要手动`store`.

注意初始化时的**类型转换**、数组初始化时的**对齐**、如果是常量则需要加入自己定义的**常量符号表**。

#### LVal

本节点区分获取常量语义值与获取变量分配的指针。通过全局变量`get_const()`来告诉本节点获取哪一类的值。查符号表，找到变量分配的内存地址；查常量表，获取常量语义值。

获取常量则根据常量表查找的结果生成`Constant*`类型的值，存在`recent_value`中。

由于在全局作用域中，访问左值表达式只有可能是在初始化时进行的，而全局变量的初始化必须是常量，所以获取变量的情形只需考虑局部作用域。

在局部作用域，根据`array_index.size()`区分两种情况：当`array_index.size()==0`时，可能是普通变量的处理也可能在函数传递参数时的指针处理，通过符号表中获取值的`type()`区分这两种情况；当`array_index.size()!=0`时，可能是普通的数组访问，此时直接发射`gep`指令即可，也可能是函数传进来的数组，则需要先`load`出指针(因为查符号表获取的是该指针分配内存的地址,是一个二维指针)，再发射`gep`指令，这两种情况同样根据`type()`区分并分别处理。

#### AssignStmt

对`target`和`value`节点分别访问，从全局变量中获取相应值，然后发射`store`指令，注意**类型转换**。

#### Literal

返回`ConstantInt`或`ConstantFloat`即可。

#### ReturnStmt

区分空返回与值返回，发射不同指令。如果是值返回，则将返回值`store`到在函数声明时已经创建好的返回值存储空间`retAlloca`，然后`branch`到同样在函数声明时已经创建好的语句块`retBB`；如果是空返回，则直接发射`branch`指令。

注意**类型转换**。

#### BlockStmt

调用`enter()`进入新的作用域同时还需要更新常量表的作用域，注意区分当前是不是一个新的函数开始，因为在`FuncDef`时就已经`enter()`了，此时就不必再`enter()`.

接下来处理语句块的每一个语句。

#### EmptyStmt

Do Nothing

#### ExprStmt

进入表达式即可。

#### UnaryCondExpr

如果`op`是非运算，则根据`rhs`的值发射`fcmp_eq`或`icmp_eq`指令。需要注意这里需要做`INT1`到`INT32`的类型转换。

#### BinaryCondExpr

对`&&`和`||`的处理：

需要考虑**短路计算**，根据保存在全局的`true`分支基本块与`false`分支基本块以及左右操作数返回值发射`branch`指令。需要注意的是为了处理短路计算，在进入左操作数之前需要生成新的`true`或`false`分支，指向右操作数，在`accept()`返回后恢复。除此以外，如果左右操作数的返回值是`INT32`或`FLOAT`类型，则需要手动发射与`0`比较的指令。将结果保存到`recent_value`中

其它关系运算符：

根据`op`不同发射不同的`cmp`指令，注意**类型转换**以及`int`和`float`对应`cmp`指令是不同的。将结果保存在`recent_value`中，便于其它节点调用。

#### UnaryExpr、BinaryExpr

根据`op`不同发射不同的算数指令即可，注意**类型转换**。

除此以外，如果运算操作数都是常量(利用`dynamic_cast()`判断)，则可以直接在编译时计算结果，存在`Constant*`变量中，返回给`recent_value`。

#### FuncCallStmt

查符号表，获取函数类型。访问`params`节点，获取实参列表，然后与符号表中的形参列表比较，做**类型转换**。最后发射`create_call()`.

#### IfStmt

根据`LLVM IR`的`if-else`语句布局特点生成`BasicBlock`，依次处理条件表达式、`if`部分、`else`部分并设置`builder`当前处理的`BasicBlock`。为了区分不同`if`语句的这些入口的`label`，增添一个序号`id`.

处理条件表达式时，如果返回的`recent_value`是`INT32`或`FLOAT`类型，需要再追加一条与`0`比较的指令，以生成`bool`型变量，然后发射`branch`指令。如果返回类型是`VOID`，说明之前已经生成了`branch`指令，在这里可以不必发射。

为了让条件表达式能正确分支，全局变量里保存了`true`分支与`false`分支的入口，`if`和`while`节点都有条件表达式，所以这两个分支是两者共用的。为了处理嵌套，进入`if`节点时需要保存当前的`true`与`false`语句块入口。

#### WhileStmt

根据`LLVM IR`的`while`语句布局特点生成`BasicBlock`，依次处理条件表达式、循环体部分并设置`builder`当前处理的`BasicBlock`。为了区分不同`while`语句的这些入口的`label`，增添一个序号`id`.

与if语句块类似，处理条件表达式时，如果返回的`recent_value`是`INT32`或`FLOAT`类型，需要再追加一条与`0`比较的指令，以生成`bool`型变量，然后发射`branch`指令。如果返回类型是`VOID`，说明之前已经生成了`branch`指令，在这里可以不必发射。

这里除了需要保存`true`和`false`语句块入口以外，由于`while`语句附带可能存在`continue`和`break`语句，所以还需要在全局变量里保存条件表达式的`BasicBlock`。为了处理嵌套，在进入`while`前保存一下这些块，在退出循环时恢复。

#### BreakStmt

全局变量里保存了当前`while`语句内的`false`语句块的`BasicBlock`，直接发射跳转指令即可。

#### ContinueStmt

全局变量里保存了当前`while`语句内的`cond`语句块的`BasicBlock`，直接发射跳转指令即可。

### 多维数组处理

使用`InitItem`结构体嵌套存储初始化常数信息。为了解决非对齐初始化的问题，在初始化之前对变量赋0，然后使用`assignInitVal`函数对变量嵌套赋值。

对于常量，单独分配一块空间用于暂存当前值，在分析初始化值的过程中同步变动。最后将这个空间打包成`Constant\*`存入常量表或作为创建全局变量的参数。

对多维数组的访问操作需区分是否为指针类型(int a[][10])，循环处理左值的类型，提取各维的下标。

## 实验难点及解决方案

#### 类型转换

类型转换在处理中随处可见，不但在表达式和赋值语句中存在，在变量初始化、函数调用时也会出现。为了统一处理，在全局声明了一个`Assign()`函数用来处理赋值时的类型转换；除此以外，对于其它的类型转换，设计足够完备的测试集进行测试。

#### 常量处理

对于`const`关键字声明的变量，它的值在运行时是不改变的。有些时候数组每一维的元素个数与全局变量的初始化可能以这些变量作为表达式，这时候获取它的常量语义值，而在函数调用时又需要返回它所在的内存地址。`scope`符号表无法做到两者同时保存，所以在这里声明了一个**全局的常量表**，用来辅助处理需要获取常量语义值的情况。通过`get_const`告诉`LVal`节点是去常量表里查询还是去普通的符号表里查询。

#### 短路计算

处理双目表达式中的`&&`和`||`时需要考虑短路计算。本质上就是发射分支指令，但是分支的目标地址需要实时更新。所以我们在全局中保存了`true`分支与`false`分支的入口。

#### 分支嵌套问题

为了处理短路计算，需要在全局保存`true`分支与`false`分支的入口；为了处理`continue`和`break`语句，需要在全局保存`while`的有关`BasicBlock`入口，但是如果上述分支节点出现嵌套，这些值会被覆盖。解决方法是每次进入`while`或`if`节点时，先保存一下有关的值，出节点时恢复。