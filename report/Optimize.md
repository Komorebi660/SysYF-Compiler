## CSE实现思路

删除过程主要分为四步：获取全部需要处理的表达式，然后建立位向量映射、可用表达式分析、根据上一步的结果将可以删除的表达式添加`delete_list`中、删除`delete_list`中的所有指令。

首先执行下面的函数:

```cpp
void GetAllExpr(Function *func);    //获取所有表达式
```
该函数遍历`func`中的每一条指令，建立表达式到位向量的映射，存储在结构体`Expr`中。

```cpp
struct Expr
{
    int expr_num; //表达式标号
    Value *lvalue;
    Value *rvalue;
    std::vector<Value *> index; //gep
    Instruction::OpID op;
};
```

接下来进行可用表达式分析，对每个基本块生成`IN`和`OUT`位向量。与通用的算法不同，由于指令为`SSA`格式，于是所有基本块的`e_kill`始终为空，可以不用考虑，所以只需要计算每个基本块的`e_gen`，得出`e_gen`后，通过迭代的方式计算`IN`和`OUT`:

```
while(有基本块的OUT发生改变)
{
    对所有基本块bb:
        IN[bb] = 该基本块的所有前驱基本块的OUT相与(AND)
        OUT[bb] = IN[bb] || e_gen(bb)
}
```

得到`IN`和`OUT`后就可以开始做公共子表达式删除了，为了处理基本块内的公共子表达式删除，对每个基本块维护一个表达式列表`expr_list`，其中存储了分析该指令之前在此基本块内已经计算过的指令，这样对每条指令，有以下两种情况：

1. 表达式在`IN`中出现，表明此时可用，则需要遍历所有前驱基本块，找到每一条路径中第一次计算该表达式的指令。寻找过程采用递归函数:
```cpp
Value *FindExpr(BasicBlock *bb, struct Expr target);
```
进行处理。需要注意的是，如果有多个基本块计算了该表示且汇聚到此基本块，那么我们不能简单地做复写操作，因为这样会破坏`SSA`格式，所以解决办法是发射`phi`指令，把不同前驱基本块计算的同一表达式汇聚到此基本块，然后删除计算指令并使用`replace_all_use_with`复写。

`SSA`格式主要是对表达式判断是否相等做出了简化，`SSA`中每个变量的值是唯一不更改的，所以只要操作数与操作符相同就意味着表达式结果相同。有一个细节需要注意，要考虑操作数为常量的情况，此时不能简单比较`Value*`，而是需要得到具体的常量值再进行比较。

2. 表达式不在`IN`中出现，则考虑是否在该基本块前面计算过，所以去查找`expr_list`，若找到，则直接复写并删除原有计算指令；若找不到，则说明本次是第一次计算，将其插入`expr_list`即可。

## CP实现思路

二元运算、类型转换、比较、零扩展指令的处理思路类似，判断它们的操作数是否为常数，如果是常数，将结果计算出来(利用`ConstFolder`类中的`computeINT`、`computeFloat`、`computeCMP`、`computeFCMP`)函数，然后使用`replace_all_use_with()`将所有用到这个表达式结果的地方替换为计算的常量，然后删除这条指令。

对于全局变量，根据题目要求，主要集中在`load/store`指令的处理，为每个基本块维护两个常量表`global_INT`、`global_Float`分别存储该基本块中可以确定值的整形常量以及浮点形常量。在处理`load`时如果表中可查得为常量，则用该常量替换所有对于这一变量的引用；对于`store`，如果存入的值为常数，则将其存入对应常量表中。

接下来需要删除不可达分支，其基本思路是对于一个完整的条件转移指令，如果`cond = 0`，则表明true分支可以删除；如果`cond`不是`0`，则表明`false`分支可以删除.删除过程主要就是删除前驱(`remove_succ_basic_block`)、后继基本块(`remove_pre_basic_block`)，但是删除时需要对存在`phi`指令进行修改，因为有些语句块不再关联，所以`phi`指令参数也需要改变，使用`remove_operands()`接口删除对应基本块的操作数即可，若`phi`的参数个数降为`2`，则可将`phi`指令删去，用其参数的值复写该变量。删去不可达基本块后，需要重新发射跳转指令。

在遍历每一个基本块中，如果其前驱基本块为空，则表明其不可达，可以通过调用`erase_from_parent()`删除。

除此以外，我们还可以对语句块中仅含一条跳转指令的情况进行优化，删去该基本块，并重新链接其前驱与后继，修改前驱的跳转指令。需要注意的是可能要对后继的`phi`指令进行修改。

## DCE实现思路

实现步骤如下:

### 准备环节

在这个阶段，扫描所有函数的所有指令，找到这些函数的`store`指令和`return`指令和函数调用指令。如果一个函数是有用的，那么它不能被删除，它的`return`语句也不能被删除，`store`指令和`call`指令也是如此。将这些指令记录下来，加到一个集合中，这个集合存放当前函数里有用的指令。

接下来判断哪些函数是必须留下的。首先`main`函数必须留下，由此递归分析要用到的函数，分析的过程类似广度优先搜索。

### Mark and Sweep

#### 标记环节

在这个环节找到每个函数要留下来的指令。

对于每个函数，已经在准备环节中找到了必须留下来的初始指令集合，由它们开始递归分析，标记所有有用的指令。分析的过程类似广度有限搜索。

- 如果一个指令被标记，那么它用到一个操作数（指令），那么这个操作数也应该被标记。

- 如果一个指令被标记，那么它的rdf（反向支配边界）的分支指令也应当被标记。（这个分支语句不能被删除是因为之后的两个分支有一个分支被标记了，所以不管删除哪个分支都会影响最终结果。）

#### 清理环节

遍历所有函数，所有指令，把没有被标记的指令删除。

如果遇到没有被标记的分支指令，则意味着分支没有什么用（如果有用的话上面的分支指令一定会被标记），那么就可以删除无用的基本块。直接把这个分支指令所在的块连接到它的反向支配节点（`j` 反向支配 `i` 意味着从`i`到`exit`块一定要经过j）就好了。

### 删除无用的块

在之前的过程中一些块不可达，或者被孤立。这里从`entry`开始搜索，找到所有可达的基本块，其它的基本块全部删除。

还可能出现连续跳转的链状基本块，可以把它们合并。


### 处理特殊情况

#### 情况1

在死代码删除中，

```
int a;
if(...)
    a=1;
else
    a=2;
......
```

那么`phi`指令所在基本块的两个前驱的代码在死代码删除这个环节就被优化掉了，phi指令直接变成了 `phi i32 [ 1, %label1 ], [ 2, %label2 ]` 这样的代码。这个指令之前的语句不会被标记（因为对编译器来说，不是在上面定义的），但是实际上应该被标记，因为实际上这个数是由分支的选择决定的。

解决办法是在处理`phi`指令时，如果遇到这种情况，就对之前的分支块一一处理，把它们的`rdf`的`branch`语句标记了。

#### 情况2

例如出现了 `phi i32 [ 1, %label1 ], [ 2, %label2 ]` 这样的语句。但是其中基本块，例如`label1`在优化的过程中可能被删除了，这就导致`phi`指令中的参数不对。

解决办法是在删除块（一定是在处理没有被标记的`branch`语句。如果是最后删除不可达的块不会出现这种情况）的时候，判断接下来的块是否有`phi`指令，并对参数一一替换。因为只有在删除块，建立新连接的时候才知道这些参数应该被替换成什么。

#### 情况3

由于`while`语句的存在，处理指令时会遇到死循环。解决办法是使用一个`map`变量记录每个指令是否被处理过。
